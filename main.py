from flask import Flask, request, render_template_string
import yt_dlp
from concurrent.futures import ThreadPoolExecutor, TimeoutError
import io

app = Flask(__name__)
executor = ThreadPoolExecutor(max_workers=1)

# YouTubeのクッキー情報を文字列として定義
# 注意: この方法はセキュリティリスクがあるため、本番環境では非推奨です。
# 開発・テスト用途に限定してください。
YOUTUBE_COOKIES = """
# Netscape HTTP Cookie File
# [https://curl.se/docs/http-cookies.html](https://curl.se/docs/http-cookies.html)

# This file was generated by yt-dlp.
# The cookies were acquired from a browser.
# Domain, Include Subdomains, Path, Secure, Expiry, Name, Value

.youtube.com\tTRUE\t/\tFALSE\t0\tPREF\ttz=UTC
.youtube.com\tTRUE\t/\tTRUE\t0\tVISITOR_INFO1_LIVE\tXR0xd-RHxkM
.youtube.com\tTRUE\t/\tTRUE\t0\tVISITOR_PRIVACY_METADATA\tCgJVUxIEGgAgJg%3D%3D
.youtube.com\tTRUE\t/\tTRUE\t0\t__Secure-ROLLOUT_TOKEN\tCMnsvMX91un_CRDE3JzWlYyPAxiQx_vWlYyPAw%3D%3D
.youtube.com\tTRUE\t/\tTRUE\t0\tYSC\twk_oCT5BVFM
.youtube.com\tTRUE\t/\tTRUE\t0\tGPS\t1
"""

# 検索処理を関数化（非同期用）
def do_search(query):
    # io.StringIOで文字列をファイルのように扱い、ydl_optsに渡す
    cookie_io = io.StringIO(YOUTUBE_COOKIES)
    
    ydl_opts = {
        'quiet': False,  # ログ有効化でデバッグ
        'no_warnings': True,
        'cookiefile': cookie_io,  # StringIOオブジェクトを直接渡す
        'user_agent': 'Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Mobile Safari/537.36',
        'socket_timeout': 60,  # 追加: ソケットタイムアウト60秒
        'extract_flat': True  # 追加: プレイリストを展開せず、検索結果のメタデータのみ取得（高速化）
    }
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        search_results = ydl.extract_info(f'ytsearch40:{query}', download=False)['entries']
    
    # 結果を動画のみにフィルタ（チャンネルやプレイリストを除外、ID長で簡易判定）
    video_results = [result for result in search_results if len(result.get('id', '')) == 11]  # 動画IDは通常11文字
    
    html = '<h1>検索結果</h1><ul>'
    for result in video_results:
        html += f'<li><a href="/video/{result["id"]}">{result["title"]}</a></li>'
    html += '</ul><a href="/">戻る</a>'
    return html

# ホーム画面: 検索フォーム
@app.route('/')
def home():
    return render_template_string('''
        <h1>YouTube動画検索サイト</h1>
        <form method="get" action="/search">
            <input name="q" placeholder="検索キーワードを入力" required>
            <button type="submit">検索</button>
        </form>
    ''')

# 検索結果画面（非同期化）
@app.route('/search')
def search():
    query = request.args.get('q')
    if not query:
        return "検索キーワードを入力してください。"
    
    future = executor.submit(do_search, query)
    try:
        return render_template_string(future.result(timeout=30))  # 30秒以内で応答、タイムアウト時はエラー
    except TimeoutError:
        return "検索がタイムアウトしました。後で再試行してください。", 504  # Gateway Timeout
    except Exception as e:
        return f"検索エラー: {str(e)}", 500

# 動画詳細画面（同様にオプション追加）
@app.route('/video/<video_id>')
def video(video_id):
    cookie_io = io.StringIO(YOUTUBE_COOKIES)
    
    ydl_opts = {
        'quiet': False,  # ログ有効化
        'no_warnings': True,
        'cookiefile': cookie_io,
        'user_agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36',
        'socket_timeout': 60  # 追加
    }
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        try:
            info = ydl.extract_info(video_id, download=False)
        except Exception as e:
            return f"動画情報取得エラー: {str(e)}"
    
    html = f'<h1>{info["title"]}</h1>'
    html += '<h2>利用可能なフォーマット（画質/音声）</h2>'
    html += '<table border="1"><tr><th>タイプ</th><th>フォーマットID</th><th>解像度/ノート</th><th>拡張子</th><th>ファイルサイズ</th><th>ビットレート</th><th>リンク</th></tr>'
    
    for fmt in info['formats']:
        format_type = '音声' if 'audio only' in fmt.get('resolution', '').lower() else '動画'
        format_id = fmt.get('format_id', '不明')
        resolution = fmt.get('resolution', '不明') if format_type == '動画' else fmt.get('format_note', 'N/A')
        ext = fmt.get('ext', '不明')
        filesize = f"{fmt.get('filesize', 0) / (1024*1024):.2f} MB" if fmt.get('filesize') else '不明'
        bitrate = f"{fmt.get('abr', 0)} kbps" if 'abr' in fmt else f"{fmt.get('vbr', 0)} kbps" if 'vbr' in fmt else '不明'
        url = fmt['url']
        
        html += f'<tr><td>{format_type}</td><td>{format_id}</td><td>{resolution}</td><td>{ext}</td><td>{filesize}</td><td>{bitrate}</td><td><a href="{url}" target="_blank">再生/ダウンロード</a></td></tr>'
    
    html += '</table>'
    html += '<a href="/">ホームに戻る</a>'
    
    return render_template_string(html)

# ローカル開発用コードは本番環境では不要
# if __name__ == '__main__':
#     app.run(debug=True)
